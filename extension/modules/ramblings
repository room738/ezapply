/* A bunch of comments from my files */

// can i import this from somewhere? 
// linkedin indeed maybe// no fb

// ez stuff: name, past jobs, resume, etc

// less ez stuff: compensation expectations, ideal start date, work auth, cover letter
// socials ==> twitter, linkedin, github, behance, dribble, blog, personal
// Work Authorization --> 
// Ideal Start Date / Availability Response

// unfillable: questions which require detail

// resume --> pdf or doc parse
// cover letter --> txt ideally but likely doc/pdf
// message to hiring manager

// TODO: update, store, manipulate, and retreive this template
// Weighted dial dropdown selector style needs to be implemented

// personal BE for user enrollments? or completely in-browser?


// find all inputs

// verify which info it needs

// fill from hash or ask


// extra shit to add to the hast
// good search for terms + ml to generate or extract tokens

// responding to radios, dropdowns, textinputs, and specific declarations
// availability, location preferences, riezone preferences i guess, job titles, ??
// specific questoins BY company (tesla.com < Tesla) <- global of companies to websites or at least accumulate it dynamically
//    --> add specific question ansers to a global database of guesses

// fills [what it knows]
// [guesses] at [low value] [options]
// [highlights] and [jumps to the next place]

// auto click stuff you dont care about
// acknowledgements, terms, 

// this is the regex?


    // parse --> parse.parse() and create `payload`
    // pull from data --> data.getUserValues(cols=payload) and create values
    // autofill --> use values to update page using js
    // update ui, data, BE--> htmx and events



// console.log("hey does this work")

// let page = document.getElementById("buttonDiv");
// let selectedClassName = "current";
// const presetButtonColors = ["#3aa757", "#e8453c", "#f9bb2d", "#4688f1"];

// // Reacts to a button click by marking the selected button and saving
// // the selection
// function handleButtonClick(event) {
//   // Remove styling from the previously selected color
//   let current = event.target.parentElement.querySelector(
//     `.${selectedClassName}`
//   );
//   if (current && current !== event.target) {
//     current.classList.remove(selectedClassName);
//   }

//   // Mark the button as selected
//   let color = event.target.dataset.color;
//   event.target.classList.add(selectedClassName);
//   chrome.storage.sync.set({ color });
// }

// // Add a button to the page for each supplied color
// function constructOptions(buttonColors) {
//   chrome.storage.sync.get("color", (data) => {
//     let currentColor = data.color;
//     // For each color we were provided…
//     for (let buttonColor of buttonColors) {
//       // …create a button with that color…
//       let button = document.createElement("button");
//       button.dataset.color = buttonColor;
//       button.style.backgroundColor = buttonColor;

//       // …mark the currently selected color…
//       if (buttonColor === currentColor) {
//         button.classList.add(selectedClassName);
//       }

//       // …and register a listener for when that button is clicked
//       button.addEventListener("click", handleButtonClick);
//       page.appendChild(button);
//     }
//   });
// }

// // Initialize the page by constructing the color options
// constructOptions(presetButtonColors);

// console.log("hey does this work")

/

  // "background": {
  //   // "service_worker": "background.js"
  // },
